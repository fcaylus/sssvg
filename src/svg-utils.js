const svgson = require('svgson');
const chroma = require('chroma-js');

/**
 * Convert a JSON representation  of a path (as generated by svg-path-parser) to a string.
 * The path data must use absolute coordinates
 */
function pathToString(d) {
    return d.map((command) => {
        switch (command.command) {
            case 'moveto':
                return `M ${command.x} ${command.y}`;
            case 'lineto':
                return `L ${command.x} ${command.y}`;
            case 'horizontal lineto':
                return `H ${command.x}`;
            case 'vertical lineto':
                return `V ${command.y}`;
            case 'curveto':
                return `C ${command.x1} ${command.y1} ${command.x2} ${command.y2} ${command.x} ${command.y}`;
            case 'smooth curveto':
                return `S ${command.x2} ${command.y2} ${command.x} ${command.y}`;
            case 'quadratic curveto':
                return `Q ${command.x1} ${command.y1} ${command.x} ${command.y}`;
            case 'smooth quadratic curveto':
                return `T ${command.x} ${command.y}`;
            case 'elliptical arc':
                return `A ${command.rx} ${command.ry} ${command.xAxisRotation} ${command.largeArc ? 1 : 0} ${command.sweep ? 1 : 0} ${command.x} ${command.y}`;
            case 'closepath':
                return 'Z';
        }
        return '';
    }).join(' ');
}

function parseViewBox(viewBoxStr) {
    if (!viewBoxStr || viewBoxStr.length === 0) {
        return undefined;
    }

    // Remove commas and plus signs, normalize and trim whitespace
    viewBoxStr = viewBoxStr.replace(/[,+]|px/g, ' ').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');

    const parts = viewBoxStr.split(' ');
    if (parts.length !== 4) {
        return undefined;
    }

    return {
        x: parseFloat(parts[0]),
        y: parseFloat(parts[1]),
        width: parseFloat(parts[2]),
        height: parseFloat(parts[3])
    };
}

function isSvgEmpty(svg) {
    return svgson.parseSync(svg).children.length === 0;
}

function containsElements(svgJson, elementsNames) {
    for (const child of svgJson.children) {
        if (child.type === 'element' && elementsNames.includes(child.name)) {
            return true;
        }

        if (child.children && containsElements(child, elementsNames)) {
            return true;
        }
    }

    return false;
}

const COLOR_ATTRIBUTES = ['color', 'background-color', 'fill', 'stroke', 'stop-color', 'flood-color'];

function listColors(svgJson) {
    const colors = [];

    function isColor(color) {
        return color && color !== 'none';
    }

    const listColorsImpl = (element) => {
        COLOR_ATTRIBUTES.forEach((attr) => {
            if (isColor(element.attributes[attr])) {
                colors.push(chroma(element.attributes[attr]).hex());
            }
        });

        // Try to find the color attributes inside the "style" attribute
        if (element.attributes.style) {
            const styles = element.attributes.style.split(';');
            styles.forEach((style) => {
                if (style.includes(':')) {
                    let [key, value] = style.split(':');
                    key = key.trim();
                    value = value.trim();

                    if (COLOR_ATTRIBUTES.includes(key) && isColor(value)) {
                        colors.push(chroma(value).hex());
                    }
                }
            });
        }

        element.children.forEach(listColorsImpl);
    };

    listColorsImpl(svgJson);
    return Array.from(new Set(colors).values());
}

module.exports = {
    parseViewBox,
    pathToString,
    isSvgEmpty,
    containsElements,
    listColors
};
